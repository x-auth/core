package controllers

import (
	"context"
	"github.com/gorilla/csrf"
	"html/template"
	"nictec.net/auth/authenticators"

	"github.com/ory/hydra-client-go/client/admin"
	"net/http"
	"nictec.net/auth/helpers"
)

func LoginOld(w http.ResponseWriter, request *http.Request){
	hydraAdmin := getAdmin()
	if request.Method == http.MethodPost{
		// parse the form ang get context
		request.ParseForm()
		ctx := context.Background()

		// challenge is now in a hidden form field
		challenge := request.PostFormValue("challenge")

		// check if the user accepted the the consent request
		if request.FormValue("submit") == "Deny access"{
			// request was denied by the user
			rejectedResponse, err := helpers.RejectLoginRequest(hydraAdmin, challenge)
			if err != nil{
				helpers.Error(w, 500, "Error rejecting Login: " + err.Error())
			}
			http.Redirect(w, request, *rejectedResponse.GetPayload().RedirectTo, 307)
			return
		}

		// try all auth providers
		authenticator, profile, authOK := authenticators.Login(request.FormValue("email"), request.FormValue("password"))

		// authentication failed, re-render the login form with error
		if !authOK{
			type LoginData struct {
				CSRFField template.HTML
				challenge string
				error string
			}
			helpers.Render(w, "login.html", "base.html", LoginData{csrf.TemplateField(request), challenge, "username or password is wrong"})
			return
		}

		// auth successful set the authenticator plugin and "tell" hydra
		cookie := http.Cookie{Name: "authenticator", Value: authenticator}
		http.SetCookie(w, &cookie)

		var remember bool
		if request.FormValue("remember") == "true"{
			remember = true
		} else {
			remember = false
		}
		loginResponse, err := helpers.AcceptLoginRequest(hydraAdmin, &profile.Email, challenge, ctx, remember)
		if err != nil{
			helpers.Error(w, 500, "Error logging in" + err.Error())
			return
		}
		http.Redirect(w, request, *loginResponse.GetPayload().RedirectTo, 307)
		return
	} else {
		query := request.URL.Query()
		ctx := context.Background()

		// the challenge is used to fetch information from hydra
		challenge_list := query["login_challenge"]
		var challenge string
		if len(challenge_list) == 0{
			helpers.Error(w, 400, "Expected a login challenge but received none")
			return
		} else {
			challenge = challenge_list[0]
		}

		// get the login request body
		requestParams := &admin.GetLoginRequestParams{LoginChallenge: challenge, Context: ctx}
		loginRequest, err := hydraAdmin.GetLoginRequest(requestParams)
		if err != nil{
			helpers.Error(w, 500, "Error getting login request " + err.Error())
			return
		}
		body := loginRequest.GetPayload()

		// if hydra was already able to authenticate te user, do not re-authenticate
		if *body.Skip{
			loginResponse, err := helpers.AcceptLoginRequest(hydraAdmin, body.Subject, challenge, ctx)
			if err != nil {

			}
			http.Redirect(w, request, *loginResponse.GetPayload().RedirectTo, 307)
			return
		}

		type LoginData struct {
			CSRFField template.HTML
			Challenge string
			Hint string
		}
		helpers.Render(w, "login.html", "base.html", LoginData{csrf.TemplateField(request), challenge, body.OidcContext.LoginHint})
	}
}